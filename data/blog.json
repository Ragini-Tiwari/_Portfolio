{
    "blogPosts": [
        {
            "slug": "building-a-rate-limiter-from-scratch",
            "title": "Building a Rate Limiter from Scratch",
            "date": "2024-12-10",
            "description": "A deep dive into implementing various rate limiting algorithms including token bucket, sliding window, and leaky bucket.",
            "tags": [
                "go",
                "system design",
                "backend"
            ],
            "readTime": "8 min read",
            "content": "Rate limiting is a crucial technique for protecting your services from abuse and ensuring fair usage among clients. In this post, we'll explore how to build rate limiters from scratch in Go.\n\n## Why Rate Limiting?\n\nRate limiting helps you:\n- Prevent API abuse\n- Protect against DDoS attacks\n- Ensure fair resource distribution\n- Control costs\n\n## Token Bucket Algorithm\n\nThe token bucket algorithm is one of the most popular rate limiting strategies. Here's how it works:\n\n1. A bucket holds tokens up to a maximum capacity\n2. Tokens are added to the bucket at a fixed rate\n3. Each request consumes a token\n4. If no tokens are available, the request is rejected"
        },
        {
            "slug": "understanding-distributed-consensus",
            "title": "Understanding Distributed Consensus",
            "date": "2024-11-28",
            "description": "Exploring Raft consensus algorithm and how distributed systems achieve agreement in the presence of failures.",
            "tags": [
                "distributed systems",
                "raft",
                "theory"
            ],
            "readTime": "12 min read",
            "content": "Distributed consensus is one of the most fundamental problems in distributed systems. How do multiple nodes agree on a value when some nodes might fail or messages might be lost?\n\n## The Consensus Problem\n\nIn a distributed system, consensus allows nodes to agree on:\n- The order of operations\n- Which node is the leader\n- The current state of the system\n\n## Raft: An Understandable Consensus Algorithm\n\nRaft was designed to be more understandable than Paxos while providing the same guarantees."
        },
        {
            "slug": "writing-an-interpreter-in-go",
            "title": "Writing an Interpreter in Go",
            "date": "2024-11-15",
            "description": "Step by step guide to building a tree-walking interpreter with lexer, parser, and evaluator.",
            "tags": [
                "go",
                "interpreters",
                "compilers"
            ],
            "readTime": "15 min read",
            "content": "Building an interpreter from scratch is one of the best ways to understand how programming languages work. In this series, we'll build a complete tree-walking interpreter for the Monkey programming language.\n\n## What We'll Build\n\n- A lexer to tokenize source code\n- A parser to build an AST\n- An evaluator to execute the AST\n- A REPL for interactive development"
        },
        {
            "slug": "concurrency-patterns-in-go",
            "title": "Concurrency Patterns in Go",
            "date": "2024-10-20",
            "description": "Common concurrency patterns including fan-out/fan-in, worker pools, and pipeline patterns.",
            "tags": [
                "go",
                "concurrency"
            ],
            "readTime": "10 min read",
            "content": "Go's concurrency primitives - goroutines and channels - make it easy to write concurrent programs. But knowing the patterns helps you write better concurrent code.\n\n## Fan-Out/Fan-In\n\nThis pattern distributes work across multiple goroutines (fan-out) and collects results (fan-in).\n\n## Worker Pools\n\nLimit the number of concurrent operations by using a fixed pool of workers.\n\n## Pipeline Pattern\n\nChain stages together where each stage processes data and passes it to the next."
        }
    ]
}